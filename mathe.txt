struct math
{
 
int mul_l_r_mod(int l , int r){
                   // sence mul[i] = (mul[i-1]  *cur[i])%mod
                   return (l==0)?mul[r]:mul[r] * mod_inv(mul[l-1]);
}
int div (int a  ,  int  b , int m){
                  return  (a%m * ModInverse(b,m)%m) % m;
}
int sum(int a , int b , int m){ // a ,b maybe negative
               return (a%m +b%m + m) % m;
}
int sub(int a , int b , int m){ // a ,b maybe negative
               return (a%m - b%m + m) % m;
}
///////////////////////////divisors part//////////////////////////////////////////////
vector<int> p;
void  prime_fact(int n){         // o log (n) * ( log(log(n) :sort)
          p.clear() ;

          while (n%2 == 0){
                    p.push_back(2);   n/=2;
          }

          for (int i = 3; i <= sqrt(n); i = i+2){
                     while (n%i == 0){
                                p.push_back(i);
                                n = n/i;
                     }
         }
         if (n > 2) p.push_back(n);
         sort(p.begin() , p.end()) ;
}

vector<pair<int,int> > val;
vector<int>  divisors;

void build(int idx , int cur){
          if (idx==val.size()){
                  divisors.push_back(cur);
                  return  ;
          }

          build(idx+1, cur);
          for (int i =1 ; i <=val[idx].S ; ++i){
                   cur*=val[idx].F;
                   build(idx+1 ,cur);
          }

}
void  build_divs(int num){          //generate divs in divsiors time

              prime_fact(num);
              divisors.clear();
              val.clear();
              for (int i = 0 ;  i<p.size() ; ++i){
                       int cnt  =1;
                       while(i+1 < p.size() and p[i]==p[i+1] ){
                               i++;
                               cnt++;
                       }
                       val.push_back({p[i] ,cnt});
              }

              build(0 , 1);


}



void lets_start_as_we_never_failed(){


    build_divs(1000);
    for (auto &val :divisors)
               cout<<val<<" ";






}
//////////////////////////////////////////////////////////////////
#define ll long long
 ll lcm(ll a, ll b){

                return a/__gcd(a,b)*b;

 }
ll nPr(ll n,ll r, ll mod){

                               ll ret = 1 ;
                               for(int i=n-r+1;i<=n;++i) ret =(ret*i)%mod;
                               return ret ;

}
int factorial[N], ways[N];
int power(int a, int b){
        if(b < 0) return 1;
         int res = 1;
         while(b){
                  if(b & 1) res = res * a % mod;
                  a = a * a % mod;
                  b >>= 1;
         }
         return res;
}
int mod_inv(int n){
         return power(n, mod - 2);
 }

int nCr(int n, int a){
        if(n < a) return 0;
        int top = factorial[n];
        int bot = mod_inv(factorial[a]) * mod_inv(factorial[n - a]); bot %= mod;
        int res = top * bot % mod;
        return res;
}

 void init(){
        factorial[0] = 1;
        for(int i = 1; i < N; i++){
                 factorial[i] = factorial[i - 1] * i;
                 factorial[i] %= mod;
        }
  }



};
