/*
   صل عل محمد
   if (u == Abdel-Aziz Mostafa )   love u <3 ;
  دايما احلم ربنا المنان

*/
#include<bits/stdc++.h>
using namespace std  ;

#define int long long           //TLE
#define F first
#define S second

#define ll int
ll random_int(ll l , ll r){
    static mt19937_64 rng(chrono::system_clock::now().time_since_epoch().count());
    return uniform_int_distribution<ll>(l,r)(rng);
}


int m=1e9+7,mod=m , p1 =257 ,  p2= 256 ;

int power(int a, int b){
        if(b < 0) return 1;
         int res = 1;
         while(b){
                  if(b & 1) res = res * a % mod;
                  a = a * a % mod;
                  b >>= 1;
         }
         return res;
}

int sub(int a , int b   ){
       return (a%mod - b%mod + mod)%mod;
}

struct Hashing {
vector<pair<int,int> >Hash , re_Hash ;

   int n  ;
Hashing(string x)
{                 //zero based

         //   l ....r    << p2 p1 p0

        n=x.size();
         Hash.resize(2*n);
         re_Hash.resize(2*n) ;






          for (int i = 0 ; i <n ; ++i){
                   Hash[i].F=Hash[i].S =  (x[i]-'0') ;
                   if (i){
                          Hash[i].F +=  Hash[i-1].F*p1 ;
                          Hash[i].S +=  Hash[i-1].S*p2 ;
                   }
                   Hash[i].F%=mod;
                   Hash[i].S%=mod;
          }
          for (int i = n-1 ; i >=0 ; --i){       //  p0 p1 p2
                   re_Hash[i].F =re_Hash[i].S =  x[i]-'0';
                   if (i!=n-1){
                           re_Hash[i].F +=re_Hash[i+1].F * p1;
                           re_Hash[i].S +=re_Hash[i+1].S *p2;

                   }
                   re_Hash[i].F %=mod;
                   re_Hash[i].S%=mod;
          }
}

pair<int ,int>  calc_hash(int l  , int r) //zero based
{
           pair<int ,int>  ans  = Hash[r];

           if (l){
              ans.F = sub(ans.F ,  Hash[l-1].F*power(p1 , r-l+1)) ;
              ans.S = sub(ans.S ,  Hash[l-1].S*power(p2 , r-l+1)) ;
           }
              return ans;
}
pair<int,int>  calc_reversed_hash(int l , int r){

          pair<int,int>  ans  = re_Hash[l] ;

          if (r!=n-1){
                  ans.F=sub(ans.F , re_Hash[r+1].F*power(p1 , r-l+1)) ;
                  ans.S=sub(ans.S , re_Hash[r+1].S*power(p2 , r-l+1)) ;
          }
          return ans ;

}
bool palindrom (int  l , int r){


              return calc_hash(l,r) ==  calc_reversed_hash(l,r)  ;

}

};





void lets_start_as_we_never_failed() {


            int n  , k ;
            cin>>n >>k;


               p1= 17;
               p2=19;



            string x;
            cin>>x;

            string t1 = "";
            string t2="";

            bool f= 0 ;


            for (int i =  0 ; i<n ; i+=k){
                     for (int  j = 0 ;j <k ; ++j){
                               if (f)
                                    t1+='0' , t2+='1';
                               else
                                    t1+='1' , t2+='0';
                     }
                     f=!f;
            }


            //cout<<t2<<"\n";



            Hashing h(x)  , h1(t1), h2(t2)  ;


            for (int i  = 1 ; i  <n ; ++i){
                     int  len  =  n-i ;;

                     if ((h.calc_hash(i,n-1) == h1.calc_hash(0,len-1)  and h.calc_reversed_hash(0 , i-1) ==h1.calc_hash(len , n-1))
                        || (h.calc_hash(i,n-1) == h2.calc_hash(0,len-1)  and h.calc_reversed_hash(0 , i-1) ==h2.calc_hash(len , n-1)))
                        return void (cout<<i<<"\n");
            }
            cout<<-1<<"\n";
}
// 2 :14
signed main() {

    ios_base::sync_with_stdio(0);
    cin.tie(0);      cout.tie(0);

    int tc=1;
    cin>>tc;
    while(tc--)
        lets_start_as_we_never_failed();

}
