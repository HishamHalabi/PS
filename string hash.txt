string x;
int n ;
 
const int N  =  3e6 ;
 
int m=1e9+7,mod=m , p1 =257 ,  p2= 19  ,p3 = 17;   // 19 , 17 , 256,  257  , 31
 
pair< int, pair<int,int> >  Hash[N] , re_Hash[N] ;
int power(int a, int b){
        if(b < 0) return 1;
         int res = 1;
         while(b){
                  if(b & 1) res = res * a % mod;
                  a = a * a % mod;
                  b >>= 1;
         }
         return res;
}
 
void pre_hash()            // n * o(power) n * log 
{                 //zero based
 
         //   l ....r    << p2 p1 p0
 
          int  mod= m ;
 
          for (int i = 0 ; i <n ; ++i){
                   Hash[i].F=Hash[i].S.F = Hash[i].S.S =(x[i]-'a') ;
                   if (i){
                          Hash[i].F   +=   Hash[i-1].F*p1 ;
                          Hash[i].S.F +=  Hash[i-1].S.F*p2 ;
                          Hash[i].S.S +=  Hash[i-1].S.S*p3 ;
                   }
                   Hash[i].F%=mod;
                   Hash[i].S.F%=mod;
                   Hash[i].S.S%=mod;
          }
          for (int i = n-1 ; i >=0 ; --i){       //  p0 p1 p2
                   re_Hash[i].F =re_Hash[i].S.F = re_Hash[i].S.S = x[i]-'a';
                   if (i!=n-1){
                           re_Hash[i].F +=re_Hash[i+1].F * p1;
                           re_Hash[i].S.F +=re_Hash[i+1].S.F *p2;
                           re_Hash[i].S.S +=re_Hash[i+1].S.S *p3;
 
                   }
                   re_Hash[i].F %=mod;
                   re_Hash[i].S.F%=mod;
                   re_Hash[i].S.S%=mod;
          }
}
int sub(int a , int b   ){
       return (a%mod - b%mod + mod)%mod;
}
pair<int ,pair<int,int> >  calc_hash(int l  , int r) //zero based
{
           pair<int ,pair<int,int> >  ans  = Hash[r];
 
           if (l){
              ans.F = sub(ans.F ,  Hash[l-1].F*power(p1 , r-l+1)) ;
              ans.S.F = sub(ans.S.F ,  Hash[l-1].S.F*power(p2 , r-l+1)) ;
              ans.S.S = sub(ans.S.S ,  Hash[l-1].S.S*power(p3 , r-l+1)) ;
           }
              return ans;
}
pair<int,pair<int,int> >  calc_reversed_hash(int l , int r){
 
          pair<int,pair<int,int> >  ans  = re_Hash[l] ;
 
          if (r!=n-1){
                  ans.F=sub(ans.F , re_Hash[r+1].F*power(p1 , r-l+1)) ;
                  ans.S.F=sub(ans.S.F , re_Hash[r+1].S.F*power(p2 , r-l+1)) ;
                  ans.S.S=sub(ans.S.S , re_Hash[r+1].S.S*power(p3 , r-l+1)) ;
          }
          return ans ;
 
}
bool palindrome (int  l , int r){
        return calc_hash(l,r) ==  calc_reversed_hash(l,r)  ;
}